// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../atma-utils

declare module 'memshare' {
    export { MemShare } from 'memshare/MemShare';
}

declare module 'memshare/MemShare' {
    import { IpcPipe } from 'memshare/IpcPipe';
    import { UpdateQuery } from 'memshare/util/types';
    export class MemShare<T> {
        name: string;
        defaultObject: T;
        pipe: IpcPipe<any>;
        data: any;
        constructor(name: string, defaultObject?: T);
        start(): Promise<void>;
        stop(): Promise<void>;
        patch(patch: UpdateQuery<T>): Promise<void>;
    }
}

declare module 'memshare/IpcPipe' {
    import { class_EventEmitter } from 'atma-utils';
    import { Channel } from 'memshare/Channel';
    import { IPipeType } from 'memshare/interface/IPipeType';
    import { IPatch, SharedObject } from 'memshare/SharedObject';
    import { UpdateQuery } from 'memshare/util/types';
    export interface IpcPipeEvents {
        starting(type: IPipeType): any;
        startingFailed(type: IPipeType, error?: any): any;
        connected(type: IPipeType): any;
    }
    export interface IpcPipeOptions {
        serverOnly?: boolean;
        clientOnly?: boolean;
    }
    export class IpcPipe<T = any> extends class_EventEmitter<IpcPipeEvents> {
        name: string;
        options?: IpcPipeOptions;
        status: 'none' | 'start-host' | 'start-client' | 'host' | 'client';
        connection: 'none' | 'connected';
        shared: SharedObject<T>;
        channel: Channel<T>;
        pending: IPatch[];
        constructor(name: string, defaultObject: any, options?: IpcPipeOptions);
        start(): Promise<void>;
        stop(): Promise<void>;
        patch(update: UpdateQuery<T>): Promise<void>;
        get(): Promise<void>;
        emit<TKey extends keyof IpcPipeEvents>(event: TKey, ...args: Parameters<IpcPipeEvents[TKey]>): this;
    }
}

declare module 'memshare/util/types' {
    /** https://docs.mongodb.com/manual/reference/operator/update */
    export type UpdateQuery<TSchema> = {
            /** https://docs.mongodb.com/manual/reference/operator/update-field/ */
            $inc?: OnlyFieldsOfType<TSchema, number | undefined>;
            $set?: MatchKeysAndValues<TSchema>;
            $unset?: OnlyFieldsOfType<TSchema, any, '' | 1 | true>;
            /** https://docs.mongodb.com/manual/reference/operator/update-array/ */
            $addToSet?: SetFields<TSchema>;
            $pop?: OnlyFieldsOfType<TSchema, any[], 1 | -1>;
            $pull?: PullOperator<TSchema>;
            $push?: PushOperator<TSchema>;
            $pullAll?: PullAllOperator<TSchema>;
    };
    type OnlyFieldsOfType<TSchema, FieldType = any, AssignableType = FieldType> = AcceptedFields<TSchema, FieldType, AssignableType> & NotAcceptedFields<TSchema, FieldType> & DotAndArrayNotation<AssignableType>;
    /** It avoid uses fields of non Type */
    type NotAcceptedFields<TSchema, FieldType> = {
            readonly [key in KeysOfOtherType<TSchema, FieldType>]?: never;
    };
    type DotAndArrayNotation<AssignableType> = {
            readonly [key: string]: AssignableType;
    };
    type KeysOfOtherType<TSchema, Type> = {
            [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? never : key;
    }[keyof TSchema];
    type SetFields<TSchema> = ({
            readonly [key in KeysOfAType<TSchema, any[] | undefined>]?: Unpacked<TSchema[key]> | AddToSetOperators<Array<Unpacked<TSchema[key]>>>;
    } & NotAcceptedFields<TSchema, any[] | undefined>) & {
            readonly [key: string]: AddToSetOperators<any> | any;
    };
    type KeysOfAType<TSchema, Type> = {
            [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? key : never;
    }[keyof TSchema];
    type AddToSetOperators<Type> = {
            $each: Type;
    };
    type Unpacked<Type> = Type extends Array<infer Element> ? Element : Type;
    type PullAllOperator<TSchema> = ({
            readonly [key in KeysOfAType<TSchema, any[]>]?: TSchema[key];
    } & NotAcceptedFields<TSchema, any[]>) & {
            readonly [key: string]: any[];
    };
    type ObjectQuerySelector<T> = T extends object ? {
            [key in keyof T]?: QuerySelector<T[key]>;
    } : QuerySelector<T>;
    type PullOperator<TSchema> = ({
            readonly [key in KeysOfAType<TSchema, any[]>]?: Partial<Unpacked<TSchema[key]>> | ObjectQuerySelector<Unpacked<TSchema[key]>>;
    } & NotAcceptedFields<TSchema, any[]>) & {
            readonly [key: string]: QuerySelector<any> | any;
    };
    type QuerySelector<T> = {
            $eq?: T;
            $gt?: T;
            $gte?: T;
            $in?: T[];
            $lt?: T;
            $lte?: T;
            $ne?: T;
            $nin?: T[];
            $not?: T extends string ? (QuerySelector<T> | RegExp) : QuerySelector<T>;
            /**
                * When `true`, `$exists` matches the documents that contain the field,
                * including documents where the field value is null.
                */
            $exists?: boolean;
            $expr?: any;
            $jsonSchema?: any;
            $mod?: T extends number ? [number, number] : never;
            $regex?: T extends string ? (RegExp | string) : never;
            $options?: T extends string ? string : never;
            $geoIntersects?: {
                    $geometry: object;
            };
            $geoWithin?: object;
            $near?: object;
            $nearSphere?: object;
            $maxDistance?: number;
            $all?: T extends Array<infer U> ? any[] : never;
            $elemMatch?: T extends Array<infer U> ? object : never;
            $size?: T extends Array<infer U> ? number : never;
    };
    type PushOperator<TSchema> = ({
            readonly [key in KeysOfAType<TSchema, any[]>]?: Unpacked<TSchema[key]> | ArrayOperator<Array<Unpacked<TSchema[key]>>>;
    } & NotAcceptedFields<TSchema, any[]>) & {
            readonly [key: string]: ArrayOperator<any> | any;
    };
    type MatchKeysAndValues<TSchema> = ReadonlyPartial<TSchema> & DotAndArrayNotation<any>;
    type ArrayOperator<Type> = {
            $each: Type;
            $slice?: number;
            $position?: number;
            $sort?: SortValues | Record<string, SortValues>;
    };
    type ReadonlyPartial<TSchema> = {
            readonly [key in keyof TSchema]?: TSchema[key];
    };
    type SortValues = -1 | 1;
    type AcceptedFields<TSchema, FieldType, AssignableType> = {
            readonly [key in KeysOfAType<TSchema, FieldType>]?: AssignableType;
    };
    export {};
}

declare module 'memshare/Channel' {
    import { class_EventEmitter } from 'atma-utils';
    import { IPatch, SharedObject } from 'memshare/SharedObject';
    export interface IChannelEvents {
        disconnect(): any;
    }
    export abstract class Channel<T> extends class_EventEmitter<IChannelEvents> {
        shared: SharedObject;
        abstract name: string;
        localVersion: number;
        netVersion: number;
        id: number;
        patches: IPatch[];
        pending: IPatch[];
        isReady: boolean;
        constructor(shared: SharedObject);
        abstract open(): Promise<any>;
        abstract close(): Promise<any>;
        abstract send(patches: IPatch<any>[]): Promise<any>;
        protected onOpen(): void;
    }
}

declare module 'memshare/interface/IPipeType' {
    export type IPipeType = 'host' | 'client';
}

declare module 'memshare/SharedObject' {
    import { UpdateQuery } from 'memshare/util/types';
    export class SharedObject<T = any> {
        version: number;
        timestamp: number;
        data: T;
        patches: IPatch<T>[];
        constructor(defaultObject?: any);
        patch(update: UpdateQuery<T>, version?: number): {
            version: number;
            timestamp: number;
            patch: UpdateQuery<T>;
        };
        toJson(): {
            version: number;
            timestamp: number;
            data: T;
        };
    }
    export interface IPatch<T = any> {
        version: number;
        timestamp: number;
        patch: UpdateQuery<T>;
    }
}

